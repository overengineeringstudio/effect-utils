import { describe, expect, it } from 'vitest'

import { EffectPath, type MegarepoConfig } from '../../config.ts'
import { generateEnvrcContent, generateWorkspaceFlakeContent } from './mod.ts'

const createTestConfig = (members: Record<string, string>): typeof MegarepoConfig.Type => ({
  members,
})

const testMegarepoRoot = EffectPath.unsafe.absoluteDir('/test/megarepo/')

describe('nix generator', () => {
  describe('generateEnvrcContent', () => {
    it('should generate envrc content with member names', () => {
      const content = generateEnvrcContent({
        options: {
          megarepoRootOutermost: testMegarepoRoot,
          megarepoRootNearest: testMegarepoRoot,
          config: createTestConfig({
            effect: 'effect-ts/effect',
            schema: 'effect-ts/schema',
          }),
        },
        workspaceRoot: testMegarepoRoot,
      })

      expect(content).toContain('MEGAREPO_ROOT_OUTERMOST="/test/megarepo/"')
      expect(content).toContain('MEGAREPO_ROOT_NEAREST="/test/megarepo/"')
      expect(content).toContain('MEGAREPO_MEMBERS="effect,schema"')
      expect(content).toContain('MEGAREPO_NIX_WORKSPACE="/test/megarepo/"')
      expect(content).toContain('# Generated by megarepo')
      expect(content).toContain('# Regenerate with: mr generate nix')
    })

    it('should generate envrc content with empty members', () => {
      const content = generateEnvrcContent({
        options: {
          megarepoRootOutermost: testMegarepoRoot,
          megarepoRootNearest: testMegarepoRoot,
          config: createTestConfig({}),
        },
        workspaceRoot: testMegarepoRoot,
      })

      expect(content).toContain('MEGAREPO_ROOT_OUTERMOST="/test/megarepo/"')
      expect(content).toContain('MEGAREPO_MEMBERS=""')
    })

    it('should generate envrc content with single member', () => {
      const content = generateEnvrcContent({
        options: {
          megarepoRootOutermost: testMegarepoRoot,
          megarepoRootNearest: testMegarepoRoot,
          config: createTestConfig({
            'my-lib': 'owner/my-lib',
          }),
        },
        workspaceRoot: testMegarepoRoot,
      })

      expect(content).toContain('MEGAREPO_MEMBERS="my-lib"')
    })

    it('should use absolute path for MEGAREPO_ROOT_OUTERMOST', () => {
      const customRoot = EffectPath.unsafe.absoluteDir('/home/user/workspace/')
      const content = generateEnvrcContent({
        options: {
          megarepoRootOutermost: customRoot,
          megarepoRootNearest: customRoot,
          config: createTestConfig({}),
        },
        workspaceRoot: customRoot,
      })

      expect(content).toContain('MEGAREPO_ROOT_OUTERMOST="/home/user/workspace/"')
    })
  })

  describe('generateWorkspaceFlakeContent', () => {
    it('should generate flake inputs for each repo', () => {
      const content = generateWorkspaceFlakeContent([
        { name: 'app', path: EffectPath.unsafe.absoluteDir('/test/megarepo/repos/app/') },
        {
          name: 'shared-lib',
          path: EffectPath.unsafe.absoluteDir('/test/megarepo/repos/shared-lib/'),
        },
      ])

      expect(content).toContain('"app" = { url = "path:./app"; };')
      expect(content).toContain('"shared-lib" = { url = "path:./shared-lib"; };')
    })

    it('should include repos output', () => {
      const content = generateWorkspaceFlakeContent([
        { name: 'app', path: EffectPath.unsafe.absoluteDir('/test/megarepo/repos/app/') },
      ])

      expect(content).toContain('repos = builtins.removeAttrs inputs [ "self" ];')
      expect(content).toContain('repos = repos;')
      expect(content).toContain('packages = bySystem packagesFor;')
      expect(content).toContain('apps = bySystem appsFor;')
    })
  })
})
