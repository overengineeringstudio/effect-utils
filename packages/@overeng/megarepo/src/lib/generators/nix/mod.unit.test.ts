import { describe, expect, it } from 'vitest'

import { EffectPath, type MegarepoConfig } from '../../config.ts'
import { generateEnvrcContent, generateWorkspaceFlakeContent } from './mod.ts'

const createTestConfig = (members: Record<string, string>): typeof MegarepoConfig.Type => ({
  members,
})

const testMegarepoRoot = EffectPath.unsafe.absoluteDir('/test/megarepo/')

describe('nix generator', () => {
  describe('generateEnvrcContent', () => {
    it('should generate envrc content with member names', () => {
      const content = generateEnvrcContent({
        options: {
          megarepoRootOutermost: testMegarepoRoot,
          megarepoRootNearest: testMegarepoRoot,
          config: createTestConfig({
            effect: 'effect-ts/effect',
            schema: 'effect-ts/schema',
          }),
        },
        workspaceRoot: testMegarepoRoot,
      })

      expect(content).toContain('find_megarepo_root_nearest()')
      expect(content).toContain('find_megarepo_root_outermost()')
      expect(content).toContain('MEGAREPO_ROOT_NEAREST="$(find_megarepo_root_nearest "$(pwd)")"')
      expect(content).toContain(
        'MEGAREPO_ROOT_OUTERMOST="$(find_megarepo_root_outermost "$MEGAREPO_ROOT_NEAREST")"',
      )
      expect(content).toContain('MEGAREPO_MEMBERS="effect,schema"')
      expect(content).toContain(
        'MEGAREPO_NIX_WORKSPACE="${MEGAREPO_ROOT_NEAREST}.direnv/megarepo-nix/workspace"',
      )
      expect(content).toContain('# Generated by megarepo')
      expect(content).toContain('# Generated at:')
      expect(content).toContain('# Generator: mr 0.1.0')
      expect(content).toContain('# Regenerate with: mr generate nix')
    })

    it('should generate envrc content with empty members', () => {
      const content = generateEnvrcContent({
        options: {
          megarepoRootOutermost: testMegarepoRoot,
          megarepoRootNearest: testMegarepoRoot,
          config: createTestConfig({}),
        },
        workspaceRoot: testMegarepoRoot,
      })

      expect(content).toContain('MEGAREPO_MEMBERS=""')
    })

    it('should generate envrc content with single member', () => {
      const content = generateEnvrcContent({
        options: {
          megarepoRootOutermost: testMegarepoRoot,
          megarepoRootNearest: testMegarepoRoot,
          config: createTestConfig({
            'my-lib': 'owner/my-lib',
          }),
        },
        workspaceRoot: testMegarepoRoot,
      })

      expect(content).toContain('MEGAREPO_MEMBERS="my-lib"')
    })

    it('should set MEGAREPO_ROOT_* via dynamic discovery', () => {
      const content = generateEnvrcContent({
        options: {
          megarepoRootOutermost: testMegarepoRoot,
          megarepoRootNearest: testMegarepoRoot,
          config: createTestConfig({}),
        },
        workspaceRoot: testMegarepoRoot,
      })

      expect(content).toContain('MEGAREPO_ROOT_NEAREST="${MEGAREPO_ROOT_NEAREST%/}/"')
      expect(content).toContain('MEGAREPO_ROOT_OUTERMOST="${MEGAREPO_ROOT_OUTERMOST%/}/"')
    })
  })

  describe('generateWorkspaceFlakeContent', () => {
    it('should generate flake inputs for each repo', () => {
      const content = generateWorkspaceFlakeContent([
        {
          name: 'app',
          path: EffectPath.unsafe.absoluteDir('/test/megarepo/repos/app/'),
        },
        {
          name: 'shared-lib',
          path: EffectPath.unsafe.absoluteDir('/test/megarepo/repos/shared-lib/'),
        },
      ])

      expect(content).toContain('"app" = { url = "path:./app"; };')
      expect(content).toContain('"shared-lib" = { url = "path:./shared-lib"; };')
    })

    it('should include repos output', () => {
      const content = generateWorkspaceFlakeContent([
        {
          name: 'app',
          path: EffectPath.unsafe.absoluteDir('/test/megarepo/repos/app/'),
        },
      ])

      expect(content).toContain('repos = builtins.removeAttrs inputs [ "self" ];')
      expect(content).toContain('repos = repos;')
      expect(content).toContain('packages = bySystem packagesFor;')
      expect(content).toContain('apps = bySystem appsFor;')
    })
  })
})
