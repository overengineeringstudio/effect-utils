import { describe, expect, it } from 'vitest'

import { EffectPath, type MegarepoConfig } from '../../config.ts'
import {
  createGeneratedFileContent,
  extractContentHash,
  generateEnvrcContent,
  generateWorkspaceFlakeContent,
  shouldWriteGeneratedFile,
} from './mod.ts'

const createTestConfig = (members: Record<string, string>): typeof MegarepoConfig.Type => ({
  members,
})

const testMegarepoRoot = EffectPath.unsafe.absoluteDir('/test/megarepo/')

describe('nix generator', () => {
  describe('generateEnvrcContent', () => {
    it('should generate envrc content with member names', () => {
      const content = generateEnvrcContent({
        options: {
          megarepoRootOutermost: testMegarepoRoot,
          megarepoRootNearest: testMegarepoRoot,
          config: createTestConfig({
            effect: 'effect-ts/effect',
            schema: 'effect-ts/schema',
          }),
        },
        workspaceRoot: testMegarepoRoot,
      })

      expect(content).toContain('find_megarepo_root_nearest()')
      expect(content).toContain('find_megarepo_root_outermost()')
      expect(content).toContain('MEGAREPO_ROOT_NEAREST="$(find_megarepo_root_nearest "$(pwd)")"')
      expect(content).toContain(
        'MEGAREPO_ROOT_OUTERMOST="$(find_megarepo_root_outermost "$MEGAREPO_ROOT_NEAREST")"',
      )
      expect(content).toContain('MEGAREPO_MEMBERS="effect,schema"')
      expect(content).toContain(
        'MEGAREPO_NIX_WORKSPACE="${MEGAREPO_ROOT_NEAREST}.direnv/megarepo-nix/workspace"',
      )
    })

    it('should generate envrc content with empty members', () => {
      const content = generateEnvrcContent({
        options: {
          megarepoRootOutermost: testMegarepoRoot,
          megarepoRootNearest: testMegarepoRoot,
          config: createTestConfig({}),
        },
        workspaceRoot: testMegarepoRoot,
      })

      expect(content).toContain('MEGAREPO_MEMBERS=""')
    })

    it('should generate envrc content with single member', () => {
      const content = generateEnvrcContent({
        options: {
          megarepoRootOutermost: testMegarepoRoot,
          megarepoRootNearest: testMegarepoRoot,
          config: createTestConfig({
            'my-lib': 'owner/my-lib',
          }),
        },
        workspaceRoot: testMegarepoRoot,
      })

      expect(content).toContain('MEGAREPO_MEMBERS="my-lib"')
    })

    it('should set MEGAREPO_ROOT_* via dynamic discovery', () => {
      const content = generateEnvrcContent({
        options: {
          megarepoRootOutermost: testMegarepoRoot,
          megarepoRootNearest: testMegarepoRoot,
          config: createTestConfig({}),
        },
        workspaceRoot: testMegarepoRoot,
      })

      expect(content).toContain('MEGAREPO_ROOT_NEAREST="${MEGAREPO_ROOT_NEAREST%/}/"')
      expect(content).toContain('MEGAREPO_ROOT_OUTERMOST="${MEGAREPO_ROOT_OUTERMOST%/}/"')
    })
  })

  describe('content hash utilities', () => {
    it('should extract content hash from header', () => {
      const content = `# Generated by megarepo
# Content hash: abc12345
some content`
      expect(extractContentHash(content)).toBe('abc12345')
    })

    it('should return undefined when no hash present', () => {
      const content = `# No hash here
some content`
      expect(extractContentHash(content)).toBeUndefined()
    })

    it('should only check first 10 lines for hash', () => {
      const lines = Array(15).fill('# comment').join('\n')
      const content = lines + '\n# Content hash: toolate'
      expect(extractContentHash(content)).toBeUndefined()
    })

    it('createGeneratedFileContent should include content hash in header', () => {
      const content = 'some functional content'
      const result = createGeneratedFileContent(content)

      expect(result).toContain('# Generated by megarepo')
      expect(result).toContain('# Content hash:')
      expect(result).toContain('# MR version:')
      expect(result).toContain(content)
    })

    it('shouldWriteGeneratedFile returns true for new files', () => {
      expect(shouldWriteGeneratedFile(undefined, 'new content')).toBe(true)
    })

    it('shouldWriteGeneratedFile returns true when no hash in existing file', () => {
      expect(shouldWriteGeneratedFile('old content without hash', 'new content')).toBe(true)
    })

    it('shouldWriteGeneratedFile returns false when content unchanged', () => {
      const content = 'same content'
      const existingFile = createGeneratedFileContent(content)
      expect(shouldWriteGeneratedFile(existingFile, content)).toBe(false)
    })

    it('shouldWriteGeneratedFile returns true when content changed', () => {
      const oldContent = 'old content'
      const existingFile = createGeneratedFileContent(oldContent)
      expect(shouldWriteGeneratedFile(existingFile, 'new content')).toBe(true)
    })

    it('hash should be deterministic for same content', () => {
      const content = 'test content'
      const file1 = createGeneratedFileContent(content)
      const file2 = createGeneratedFileContent(content)

      const hash1 = extractContentHash(file1)
      const hash2 = extractContentHash(file2)

      expect(hash1).toBe(hash2)
    })
  })

  describe('generateWorkspaceFlakeContent', () => {
    it('should generate flake inputs for each repo', () => {
      const content = generateWorkspaceFlakeContent([
        {
          name: 'app',
          path: EffectPath.unsafe.absoluteDir('/test/megarepo/repos/app/'),
        },
        {
          name: 'shared-lib',
          path: EffectPath.unsafe.absoluteDir('/test/megarepo/repos/shared-lib/'),
        },
      ])

      expect(content).toContain('"app" = { url = "path:./app"; };')
      expect(content).toContain('"shared-lib" = { url = "path:./shared-lib"; };')
    })

    it('should include repos output', () => {
      const content = generateWorkspaceFlakeContent([
        {
          name: 'app',
          path: EffectPath.unsafe.absoluteDir('/test/megarepo/repos/app/'),
        },
      ])

      expect(content).toContain('repos = builtins.removeAttrs inputs [ "self" ];')
      expect(content).toContain('repos = repos;')
      expect(content).toContain('packages = bySystem packagesFor;')
      expect(content).toContain('apps = bySystem appsFor;')
    })
  })
})
