/**
 * Nix Workspace Generator
 *
 * Generates a local Nix workspace under `.direnv/megarepo-nix/workspace`
 * and writes `.envrc.generated.megarepo` for direnv integration.
 */

import { Command, FileSystem } from '@effect/platform'
import { Effect, Schema } from 'effect'

import {
  EffectPath,
  getMemberPath,
  type AbsoluteDirPath,
  type AbsoluteFilePath,
  type MegarepoConfig,
} from '../../config.ts'

/** Error when generating the Nix workspace fails */
export class NixGeneratorError extends Schema.TaggedError<NixGeneratorError>()(
  'NixGeneratorError',
  {
    message: Schema.String,
    cause: Schema.optional(Schema.Defect),
  },
) {}

/** Options for the Nix workspace generator */
export interface NixGeneratorOptions {
  /** Path to the outermost megarepo root */
  readonly megarepoRootOutermost: AbsoluteDirPath
  /** Path to the nearest megarepo root */
  readonly megarepoRootNearest: AbsoluteDirPath
  /** The megarepo config */
  readonly config: typeof MegarepoConfig.Type
}

/** Result of the Nix workspace generation */
export interface NixGeneratorResult {
  readonly workspaceRoot: AbsoluteDirPath
  readonly flakePath: AbsoluteFilePath
  readonly envrcPath: AbsoluteFilePath
}

interface WorkspaceFlakeRepo {
  readonly name: string
  readonly path: AbsoluteDirPath
}

const defaultWorkspaceDir = '.direnv/megarepo-nix/workspace/'

const normalizeWorkspaceDir = (rawDir: string): string =>
  rawDir.endsWith('/') ? rawDir : `${rawDir}/`

/** Generate the content for .envrc.generated.megarepo */
export const generateEnvrcContent = ({
  options,
  workspaceRoot,
}: {
  options: NixGeneratorOptions
  workspaceRoot: AbsoluteDirPath
}): string => {
  const memberNames = Object.keys(options.config.members).join(',')

  return `# Generated by megarepo - do not edit manually
# Regenerate with: mr generate nix

export MEGAREPO_ROOT_OUTERMOST="${options.megarepoRootOutermost}"
export MEGAREPO_ROOT_NEAREST="${options.megarepoRootNearest}"
export MEGAREPO_MEMBERS="${memberNames}"
export MEGAREPO_NIX_WORKSPACE="${workspaceRoot}"
`
}

/** Generate the content for the workspace flake.nix */
export const generateWorkspaceFlakeContent = (repos: readonly WorkspaceFlakeRepo[]): string => {
  const inputs = repos.map(({ name }) => `    "${name}" = { url = "path:./${name}"; };`).join('\n')

  return [
    '{',
    '  inputs = {',
    inputs,
    '  };',
    '',
    '  outputs = inputs@{ self, ... }:',
    '    let',
    '      repos = builtins.removeAttrs inputs [ "self" ];',
    '      systems = [',
    '        "x86_64-linux"',
    '        "aarch64-linux"',
    '        "x86_64-darwin"',
    '        "aarch64-darwin"',
    '      ];',
    '      packagesFor = system:',
    '        builtins.mapAttrs (_: repo:',
    '          if repo ? packages && builtins.hasAttr system repo.packages then',
    '            repo.packages.${system}',
    '          else',
    '            { }',
    '        ) repos;',
    '      appsFor = system:',
    '        builtins.mapAttrs (_: repo:',
    '          if repo ? apps && builtins.hasAttr system repo.apps then',
    '            repo.apps.${system}',
    '          else',
    '            { }',
    '        ) repos;',
    '      bySystem = f:',
    '        builtins.listToAttrs (map (system: { name = system; value = f system; }) systems);',
    '    in',
    '    {',
    '      repos = repos;',
    '      packages = bySystem packagesFor;',
    '      apps = bySystem appsFor;',
    '    };',
    '}',
    '',
  ].join('\n')
}

const rsyncRepo = Effect.fn('megarepo/nix/rsyncRepo')(function* (source: string, dest: string) {
  // Mirror repos into the workspace without copying heavy build outputs.
  const args = [
    '-a',
    '--copy-links',
    '--delete',
    '--prune-empty-dirs',
    // Always include bun.lock, even if a repo's .gitignore would exclude it.
    '--filter',
    '+ bun.lock',
    '--filter',
    '+ **/bun.lock',
    '--filter',
    ':- .gitignore',
    '--exclude',
    '.git',
    '--exclude',
    '.direnv',
    '--exclude',
    '.devenv',
    '--exclude',
    'result',
    '--exclude',
    'tmp',
    '--exclude',
    'node_modules',
    `${source}/`,
    `${dest}/`,
  ]

  const command = Command.make('rsync', ...args).pipe(
    Command.stdout('inherit'),
    Command.stderr('inherit'),
  )

  const exitCode = yield* Command.exitCode(command).pipe(
    Effect.mapError(
      (cause) =>
        new NixGeneratorError({
          message: `rsync failed for ${source}`,
          cause,
        }),
    ),
  )

  if (exitCode === 23) {
    yield* Effect.logWarning(`rsync warning (code 23) while syncing ${source}`)
    return
  }

  if (exitCode !== 0) {
    return yield* new NixGeneratorError({
      message: `rsync failed for ${source}`,
    })
  }
})

/** Generate the Nix workspace for a megarepo */
export const generateNix = Effect.fn('megarepo/generate/nix')(function* (
  options: NixGeneratorOptions,
): Effect.Effect<NixGeneratorResult, NixGeneratorError> {
  const fs = yield* FileSystem.FileSystem
  const repoRoot = options.megarepoRootNearest
  const repoNames = Object.keys(options.config.members).toSorted()

  if (repoNames.length === 0) {
    return yield* new NixGeneratorError({
      message: 'megarepo.json has no members to sync',
    })
  }

  const workspaceDir = options.config.generators?.nix?.workspaceDir ?? defaultWorkspaceDir
  const workspaceRoot = EffectPath.ops.join(
    repoRoot,
    EffectPath.unsafe.relativeDir(normalizeWorkspaceDir(workspaceDir)),
  )

  yield* fs.makeDirectory(workspaceRoot, { recursive: true })

  const flakePath = EffectPath.ops.join(workspaceRoot, EffectPath.unsafe.relativeFile('flake.nix'))
  const envrcPath = EffectPath.ops.join(
    repoRoot,
    EffectPath.unsafe.relativeFile('.envrc.generated.megarepo'),
  )

  const repoInputs: WorkspaceFlakeRepo[] = []
  const mirrorRepos: WorkspaceFlakeRepo[] = []
  for (const repoName of repoNames) {
    const source = getMemberPath({ megarepoRoot: repoRoot, name: repoName })
    const exists = yield* fs.exists(source)
    if (!exists) {
      return yield* new NixGeneratorError({
        message: `Repo ${repoName} does not exist at ${source}`,
      })
    }
    mirrorRepos.push({ name: repoName, path: source })

    const repoFlakePath = EffectPath.ops.join(source, EffectPath.unsafe.relativeFile('flake.nix'))
    if (yield* fs.exists(repoFlakePath)) {
      repoInputs.push({ name: repoName, path: source })
    } else {
      yield* Effect.logWarning(`Skipping ${repoName} in workspace flake (no flake.nix found).`)
    }
  }

  yield* fs.writeFileString(flakePath, generateWorkspaceFlakeContent(repoInputs))
  yield* fs.writeFileString(envrcPath, generateEnvrcContent({ options, workspaceRoot }))

  for (const repo of mirrorRepos) {
    const dest = EffectPath.ops.join(workspaceRoot, EffectPath.unsafe.relativeDir(`${repo.name}/`))
    yield* fs.makeDirectory(dest, { recursive: true })
    yield* rsyncRepo(repo.path, dest)
  }

  return { workspaceRoot, flakePath, envrcPath }
})
