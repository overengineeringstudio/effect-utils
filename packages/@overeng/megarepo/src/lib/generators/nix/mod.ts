/**
 * Nix Workspace Generator
 *
 * Generates a local Nix workspace under `.direnv/megarepo-nix/workspace`
 * and writes `.envrc.generated.megarepo` for direnv integration.
 */

import { Command, FileSystem } from '@effect/platform'
import { Effect, Schema } from 'effect'

import {
  EffectPath,
  getMemberPath,
  type AbsoluteDirPath,
  type AbsoluteFilePath,
  type MegarepoConfig,
} from '../../config.ts'
import { MR_VERSION } from '../../version.ts'

/** Error when generating the Nix workspace fails */
export class NixGeneratorError extends Schema.TaggedError<NixGeneratorError>()(
  'NixGeneratorError',
  {
    message: Schema.String,
    cause: Schema.optional(Schema.Defect),
  },
) {}

/** Options for the Nix workspace generator */
export interface NixGeneratorOptions {
  /** Path to the outermost megarepo root */
  readonly megarepoRootOutermost: AbsoluteDirPath
  /** Path to the nearest megarepo root */
  readonly megarepoRootNearest: AbsoluteDirPath
  /** The megarepo config */
  readonly config: typeof MegarepoConfig.Type
}

/** Result of the Nix workspace generation */
export interface NixGeneratorResult {
  readonly workspaceRoot: AbsoluteDirPath
  readonly flakePath: AbsoluteFilePath
  readonly envrcPath: AbsoluteFilePath
}

interface WorkspaceFlakeRepo {
  readonly name: string
  readonly path: AbsoluteDirPath
}

const defaultWorkspaceDir = '.direnv/megarepo-nix/workspace/'

const normalizeWorkspaceDir = (rawDir: string): string =>
  rawDir.endsWith('/') ? rawDir : `${rawDir}/`

const pad = (value: number): string => value.toString().padStart(2, '0')

const formatTimestamp = (date: Date = new Date()): string => {
  const offsetMinutes = -date.getTimezoneOffset()
  const sign = offsetMinutes >= 0 ? '+' : '-'
  const absOffset = Math.abs(offsetMinutes)
  const offsetHours = pad(Math.floor(absOffset / 60))
  const offsetMins = pad(absOffset % 60)

  return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ${pad(
    date.getHours(),
  )}:${pad(date.getMinutes())}:${pad(date.getSeconds())} ${sign}${offsetHours}:${offsetMins}`
}

/** Generate the content for .envrc.generated.megarepo */
export const generateEnvrcContent = ({
  options,
  workspaceRoot: _workspaceRoot,
}: {
  options: NixGeneratorOptions
  workspaceRoot: AbsoluteDirPath
}): string => {
  const memberNames = Object.keys(options.config.members).join(',')

  return `# Generated by megarepo - do not edit manually
# Generated at: ${formatTimestamp()}
# Generator: mr ${MR_VERSION}
# Regenerate with: mr generate nix

find_megarepo_root_nearest() {
  local current="$1"
  local last=""
  while [ -n "$current" ] && [ "$current" != "/" ] && [ "$current" != "$last" ]; do
    if [ -f "$current/megarepo.json" ]; then
      echo "$current"
      return 0
    fi
    last="$current"
    current="$(dirname "$current")"
  done
  return 1
}

find_megarepo_root_outermost() {
  local current="$1"
  local last=""
  local candidate=""
  while [ -n "$current" ] && [ "$current" != "/" ] && [ "$current" != "$last" ]; do
    if [ -f "$current/megarepo.json" ]; then
      candidate="$current"
    fi
    last="$current"
    current="$(dirname "$current")"
  done
  if [ -n "$candidate" ]; then
    echo "$candidate"
    return 0
  fi
  return 1
}

MEGAREPO_ROOT_NEAREST="$(find_megarepo_root_nearest "$(pwd)")" || {
  echo "megarepo: megarepo.json not found in parent dirs of $(pwd)" >&2
  return 1 2>/dev/null || exit 1
}
MEGAREPO_ROOT_OUTERMOST="$(find_megarepo_root_outermost "$MEGAREPO_ROOT_NEAREST")" || {
  echo "megarepo: megarepo.json not found above $MEGAREPO_ROOT_NEAREST" >&2
  return 1 2>/dev/null || exit 1
}
MEGAREPO_ROOT_NEAREST="\${MEGAREPO_ROOT_NEAREST%/}/"
MEGAREPO_ROOT_OUTERMOST="\${MEGAREPO_ROOT_OUTERMOST%/}/"

export MEGAREPO_ROOT_OUTERMOST
export MEGAREPO_ROOT_NEAREST
export MEGAREPO_MEMBERS="${memberNames}"
export MEGAREPO_NIX_WORKSPACE="\${MEGAREPO_ROOT_NEAREST}.direnv/megarepo-nix/workspace"
`
}

/** Generate the content for the workspace flake.nix */
export const generateWorkspaceFlakeContent = (repos: readonly WorkspaceFlakeRepo[]): string => {
  const inputs = repos.map(({ name }) => `    "${name}" = { url = "path:./${name}"; };`).join('\n')

  return [
    '{',
    '  inputs = {',
    inputs,
    '  };',
    '',
    '  outputs = inputs@{ self, ... }:',
    '    let',
    '      repos = builtins.removeAttrs inputs [ "self" ];',
    '      systems = [',
    '        "x86_64-linux"',
    '        "aarch64-linux"',
    '        "x86_64-darwin"',
    '        "aarch64-darwin"',
    '      ];',
    '      packagesFor = system:',
    '        builtins.mapAttrs (_: repo:',
    '          if repo ? packages && builtins.hasAttr system repo.packages then',
    '            repo.packages.${system}',
    '          else',
    '            { }',
    '        ) repos;',
    '      appsFor = system:',
    '        builtins.mapAttrs (_: repo:',
    '          if repo ? apps && builtins.hasAttr system repo.apps then',
    '            repo.apps.${system}',
    '          else',
    '            { }',
    '        ) repos;',
    '      bySystem = f:',
    '        builtins.listToAttrs (map (system: { name = system; value = f system; }) systems);',
    '    in',
    '    {',
    '      repos = repos;',
    '      packages = bySystem packagesFor;',
    '      apps = bySystem appsFor;',
    '    };',
    '}',
    '',
  ].join('\n')
}

const rsyncRepo = Effect.fn('megarepo/nix/rsyncRepo')((source: string, dest: string) =>
  Effect.gen(function* () {
    // Mirror repos into the workspace without copying heavy build outputs.
    const args = [
      '-a',
      '--copy-links',
      '--delete',
      '--prune-empty-dirs',
      // Always include bun.lock, even if a repo's .gitignore would exclude it.
      '--filter',
      '+ bun.lock',
      '--filter',
      '+ **/bun.lock',
      '--filter',
      ':- .gitignore',
      '--exclude',
      '.git',
      '--exclude',
      '.direnv',
      '--exclude',
      '.devenv',
      '--exclude',
      'result',
      '--exclude',
      'tmp',
      '--exclude',
      'node_modules',
      `${source}/`,
      `${dest}/`,
    ]

    const command = Command.make('rsync', ...args).pipe(
      Command.stdout('inherit'),
      Command.stderr('inherit'),
    )

    const exitCode = yield* Command.exitCode(command).pipe(
      Effect.mapError(
        (cause) =>
          new NixGeneratorError({
            message: `rsync failed for ${source}`,
            cause,
          }),
      ),
    )

    if (exitCode === 23) {
      yield* Effect.logWarning(`rsync warning (code 23) while syncing ${source}`)
      return
    }

    if (exitCode !== 0) {
      return yield* new NixGeneratorError({
        message: `rsync failed for ${source}`,
      })
    }
  }),
)

/** Generate the Nix workspace for a megarepo */
export const generateNix = Effect.fn('megarepo/generate/nix')((options: NixGeneratorOptions) =>
  Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem
    const repoRoot = options.megarepoRootNearest
    const repoNames = Object.keys(options.config.members).toSorted()

    // Note: We allow empty member lists - all members may be skipped via --skip

    const workspaceDir = options.config.generators?.nix?.workspaceDir ?? defaultWorkspaceDir
    const workspaceRoot = EffectPath.ops.join(
      repoRoot,
      EffectPath.unsafe.relativeDir(normalizeWorkspaceDir(workspaceDir)),
    )

    yield* fs.makeDirectory(workspaceRoot, { recursive: true })

    const flakePath = EffectPath.ops.join(
      workspaceRoot,
      EffectPath.unsafe.relativeFile('flake.nix'),
    )
    const envrcPath = EffectPath.ops.join(
      repoRoot,
      EffectPath.unsafe.relativeFile('.envrc.generated.megarepo'),
    )
    const repoInputs: WorkspaceFlakeRepo[] = []
    const mirrorRepos: WorkspaceFlakeRepo[] = []
    for (const repoName of repoNames) {
      const source = getMemberPath({ megarepoRoot: repoRoot, name: repoName })
      const exists = yield* fs.exists(source)
      if (!exists) {
        // Gracefully skip missing members - they may have been excluded via --skip
        yield* Effect.logWarning(`Skipping ${repoName} in nix generator (path does not exist).`)
        continue
      }
      mirrorRepos.push({ name: repoName, path: source })

      const repoFlakePath = EffectPath.ops.join(source, EffectPath.unsafe.relativeFile('flake.nix'))
      if (yield* fs.exists(repoFlakePath)) {
        repoInputs.push({ name: repoName, path: source })
      } else {
        yield* Effect.logWarning(`Skipping ${repoName} in workspace flake (no flake.nix found).`)
      }
    }

    const flakeContent = generateWorkspaceFlakeContent(repoInputs)
    const envrcContent = generateEnvrcContent({ options, workspaceRoot })

    // Write files only if content changed (avoids unnecessary direnv reloads)
    const flakeExists = yield* fs.exists(flakePath)
    if (!flakeExists || (yield* fs.readFileString(flakePath)) !== flakeContent) {
      yield* fs.writeFileString(flakePath, flakeContent)
    }
    const envrcExists = yield* fs.exists(envrcPath)
    if (!envrcExists || (yield* fs.readFileString(envrcPath)) !== envrcContent) {
      yield* fs.writeFileString(envrcPath, envrcContent)
    }

    for (const repo of mirrorRepos) {
      const dest = EffectPath.ops.join(
        workspaceRoot,
        EffectPath.unsafe.relativeDir(`${repo.name}/`),
      )
      yield* fs.makeDirectory(dest, { recursive: true })
      yield* rsyncRepo(repo.path, dest)
    }

    return { workspaceRoot, flakePath, envrcPath }
  }),
)
